// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GenerateParticle
#pragma kernel ResetNeighboursCounter
#pragma kernel UpdateNeighbours
#pragma kernel UpdateDensities
#pragma kernel PropagateDensityUpdate
#pragma kernel UpdateHeights
#pragma kernel PropagateHeightUpdate
#pragma kernel UpdateTemperatures
#pragma kernel PropagateTemperatureUpdate
#pragma kernel UpdateVelocities
#pragma kernel PropagateVelocityUpdate
#pragma kernel TimeIntegration
#pragma kernel PropagatePositionUpdate
#pragma kernel UpdateTerrainDensities
#pragma kernel UpdateTerrainDensitiesStar
#pragma kernel UpdateTerrainHeights
#pragma kernel GaussianBlurTerrainHeights


uniform float H;
uniform float PI;
uniform float G;

uniform float _Mu;
uniform float _Ke;
uniform float _ThetaE;
uniform float ALPHA;

uniform bool FirstTimeBlur;
uniform bool GaussianBlur;
uniform bool _DisplayLava;

uniform float STIFF;
uniform float RHO_0;

uniform float ALPHA_POLY6;
uniform float ALPHA_POLY6_LAPLACIAN;
uniform float ALPHA_VISCOSITY;
uniform float ALPHA_VISCOSITY_LAPLACIAN;

uniform float SPIKE;
uniform uint MAX_PARTICLES;
uniform uint _NbCurParticles;

uniform float DT;
uniform float RAND;

struct StaggeredGridGPU{
    uint _NbCols, _NbLines;
    float _DeltaCols, _DeltaLines;
};

struct NeighbourGridGPU{
    uint _NbCols, _NbLines;
    float _DeltaCols, _DeltaLines;
    uint _NbMaxNeighbours;
};

struct ParticleGPU{
    float3 _Velocity;
    float3 _Position;
    float  _Height;
    float3 _HeightGradient;
    float  _Density;
    float  _Mass;
    float  _Volume;
    uint   _Cell;
    uint   _Id;
    float  _Temperature;
};

uniform StructuredBuffer<StaggeredGridGPU> _StaggeredGrid;
uniform StructuredBuffer<float>  _StaggeredGridHeights;
uniform StructuredBuffer<float>  _StaggeredGridHalfHeights;
uniform StructuredBuffer<float2> _StaggeredGridGradients;
uniform StructuredBuffer<float>  _StaggeredGridLaplacians;

uniform StructuredBuffer<NeighbourGridGPU> _NeighbourGrid;
RWStructuredBuffer<float> _NeighbourGridCells;
RWStructuredBuffer<uint> _NeighbourGridCellsCounter;

RWStructuredBuffer<float> _TerrainHeightsTmp;
RWStructuredBuffer<float> _TerrainHeights;
RWStructuredBuffer<float> _InitialTerrainHeights;

RWStructuredBuffer<float> _TerrainDensities;
RWStructuredBuffer<float> _TerrainDensitiesRadii;
RWStructuredBuffer<float> _TerrainDensitiesHat;
RWStructuredBuffer<float> _TerrainDensitiesStar;
RWStructuredBuffer<float2> _TerrainDensitiesMinMax;
uniform float _TerrainDensityMax;
uniform float _TerrainDensityMin;

RWStructuredBuffer<ParticleGPU> _Particles;
RWStructuredBuffer<float3> _Positions;
RWStructuredBuffer<float3> _Velocities;
RWStructuredBuffer<float>  _Heights;
RWStructuredBuffer<float3> _HeightsGradients;
RWStructuredBuffer<float>  _Volumes;
RWStructuredBuffer<float>  _Densities;
RWStructuredBuffer<float>  _Masses;
RWStructuredBuffer<float>  _Temperatures;

uniform uint _NbNewParticles;
uniform float3 _NewPosition;
uniform float _ParticleInitialHeight;


// ##################################################################################################################
// ################################### STAGGERED GRID ###############################################################
// ##################################################################################################################
uint StaggeredGridConvertIndices(uint posZ, uint posX){
    return posX + posZ * _StaggeredGrid[0]._NbCols;
}

uint StaggeredGridConvertIndicesHalf(uint posZ, uint posX){
    return posX + posZ * (_StaggeredGrid[0]._NbCols-1);
}

uint2 StaggeredGridGetIndices(float3 pos){
    uint posX = (uint)(pos.x / _StaggeredGrid[0]._DeltaCols);
    uint posZ = (uint)(pos.z / _StaggeredGrid[0]._DeltaLines);
    return uint2(posZ, posX);
};

float3 StaggeredGridGetPosition(uint id){
    uint yId = id / _StaggeredGrid[0]._NbCols;
    uint xId = id - yId * _StaggeredGrid[0]._NbCols;

    float x = xId*_StaggeredGrid[0]._DeltaCols;
    float y = _StaggeredGridHeights[id];
    float z = yId*_StaggeredGrid[0]._DeltaLines;
    
    return float3(x,y,z);
}

float StaggeredGridBilinearInterpolation(float x, float z, float xIdx, float zIdx, float w11, float w12, float w21, float w22){
    float xLeft  = xIdx*_StaggeredGrid[0]._DeltaCols;
    float xRight = (xIdx+1)*_StaggeredGrid[0]._DeltaCols;
    float zUp    = (zIdx+1)*_StaggeredGrid[0]._DeltaLines;
    float zDown  = zIdx*_StaggeredGrid[0]._DeltaLines;

    float x2_prime = xRight - x;
    float x1_prime = x - xLeft;
    float z2_prime = zUp - z;
    float z1_prime = z - zDown;

    float factor = 1.0/(_StaggeredGrid[0]._DeltaCols*_StaggeredGrid[0]._DeltaLines);


    float res = ((w11*x2_prime + w21*x1_prime)*z2_prime) + ((w12*x2_prime + w22*x1_prime)*z1_prime);

    return res *= factor;
}

float StaggeredGridGetHeight(float3 pos){
    uint2 indices = StaggeredGridGetIndices(pos);
    uint zIdx = indices[0];
    uint xIdx = indices[1];

    float x = pos.x;
    float z = pos.z;

    // interpolate height, bilinearly
    float upLeft    = (zIdx >= _StaggeredGrid[0]._NbLines-1 || xIdx <= 0)                           ? 0.0f : _StaggeredGridHalfHeights[StaggeredGridConvertIndicesHalf(zIdx, xIdx-1)];
    float upRight   = (zIdx >= _StaggeredGrid[0]._NbLines-1 || xIdx >= _StaggeredGrid[0]._NbCols-1) ? 0.0f : _StaggeredGridHalfHeights[StaggeredGridConvertIndicesHalf(zIdx, xIdx)];
    float downLeft  = (zIdx <= 0 || xIdx <= 0)                                                      ? 0.0f : _StaggeredGridHalfHeights[StaggeredGridConvertIndicesHalf(zIdx-1, xIdx-1)];
    float downRight = (zIdx <= 0 || xIdx >= _StaggeredGrid[0]._NbCols-1)                            ? 0.0f : _StaggeredGridHalfHeights[StaggeredGridConvertIndicesHalf(zIdx-1, xIdx)];

    float ownRes = StaggeredGridBilinearInterpolation(x, z, xIdx, zIdx, downLeft, upLeft, downRight, upRight);
    // float ownRes =  _StaggeredGridHeights[StaggeredGridConvertIndices(zIdx, xIdx)];
    // float ownRes =  _StaggeredGridHalfHeights[StaggeredGridConvertIndicesHalf(zIdx, xIdx)];
    return ownRes;
}

float3 StaggeredGridGetGradient(ParticleGPU p){
    float3 pos = p._Position;
    uint2 indices = StaggeredGridGetIndices(pos);
    uint zIdx = indices[0];
    uint xIdx = indices[1];

    float x = pos.x;
    float z = pos.z;

    // interpolate gradients bilinearly
    float2 upLeft    = (zIdx >= _StaggeredGrid[0]._NbLines-1 || xIdx <= 0)                           ? float2(0.0f, 0.0f) : _StaggeredGridGradients[StaggeredGridConvertIndicesHalf(zIdx, xIdx-1)];
    float2 upRight   = (zIdx >= _StaggeredGrid[0]._NbLines-1 || xIdx >= _StaggeredGrid[0]._NbCols-1) ? float2(0.0f, 0.0f) : _StaggeredGridGradients[StaggeredGridConvertIndicesHalf(zIdx, xIdx)];
    float2 downLeft  = (zIdx <= 0 || xIdx <= 0)                                                      ? float2(0.0f, 0.0f) : _StaggeredGridGradients[StaggeredGridConvertIndicesHalf(zIdx-1, xIdx-1)];
    float2 downRight = (zIdx <= 0 || xIdx >= _StaggeredGrid[0]._NbCols-1)                            ? float2(0.0f, 0.0f) : _StaggeredGridGradients[StaggeredGridConvertIndicesHalf(zIdx-1, xIdx)];

    float dx, dz;

    dx = StaggeredGridBilinearInterpolation(x, z, xIdx, zIdx, downLeft.x, upLeft.x, downRight.x, upRight.x);
    dz = StaggeredGridBilinearInterpolation(x, z, xIdx, zIdx, downLeft.y, upLeft.y, downRight.y, upRight.y);
    // if(xIdx >= _StaggeredGrid[0]._NbCols-1 || zIdx >= _StaggeredGrid[0]._NbLines-1){
    //     dx = 0.0f;
    //     dz = 0.0f;
    // } else {
    //     dx = _StaggeredGridGradients[StaggeredGridConvertIndicesHalf(zIdx, xIdx)].x;
    //     dz = _StaggeredGridGradients[StaggeredGridConvertIndicesHalf(zIdx, xIdx)].y;
    // }

    return float3(dx, pos.y, dz);
}

float StaggeredGridGetLaplacian(float3 pos){
    uint2 indices = StaggeredGridGetIndices(pos);
    uint zIdx = indices[0];
    uint xIdx = indices[1];

    float x = pos.x;
    float z = pos.z;

    // interpolate gradients bilinearly
    float upLeft    = (zIdx >= _StaggeredGrid[0]._NbLines-2 || xIdx <= 1)                           ? 0.0f : _StaggeredGridLaplacians[StaggeredGridConvertIndices(zIdx-2+1, xIdx-2+0)];
    float upRight   = (zIdx >= _StaggeredGrid[0]._NbLines-2 || xIdx >= _StaggeredGrid[0]._NbCols-2) ? 0.0f : _StaggeredGridLaplacians[StaggeredGridConvertIndices(zIdx-2+1, xIdx-2+1)];
    float downLeft  = (zIdx <= 1 || xIdx <= 1)                                                      ? 0.0f : _StaggeredGridLaplacians[StaggeredGridConvertIndices(zIdx-2+0, xIdx-2+0)];
    float downRight = (zIdx <= 1 || xIdx >= _StaggeredGrid[0]._NbCols-1)                            ? 0.0f : _StaggeredGridLaplacians[StaggeredGridConvertIndices(zIdx-2+0, xIdx-2+1)];

    float ownRes = StaggeredGridBilinearInterpolation(x, z, xIdx, zIdx, upLeft, upRight, downLeft, downRight);
    return ownRes;
}



// ##################################################################################################################
// ############################################### KERNEL ###########################################################
// ##################################################################################################################
float K_POLY6(float r){
    if(r<H) {
        float tmp = (H*H-r*r);
        return tmp*tmp*tmp;
    }
    else return 0.0f;
}

float K_POLY6_Prime(float r){
    if(r<H) {
        float tmp = ((H*H)-r*r);
        return -6.0f*r*tmp*tmp;
    }
    else return 0.0f;    
}

float K_POLY6_Lap(float r){
    if(r<H) {
        float tmp = ((H*H)-r*r);
        return tmp*(2*r*r-H*H);
    }
    else return 0.0f;
}

float K_VISCOSITY(float r){
    float l = H;
    if(r<l) {
        return r*r*(-4.0f*r + 9.0f*l) + l*l*l*(-5.0f + 6.0f*(log(l)-log(r)));
    }
    else return 0.0f;
}

float K_VISCOSITY_Prime(float r){
    float l = H;
    if(r<l) {
        if(r != 0) return r*(-12.0f*r + 18.0f*l) - (6.0f*l*l*l) / r;
        return 0.0f;
    }
    else return 0.0f;
}

float KernelDistance(float3 p1, float3 p2){
    return sqrt((p1.x-p2.x)*(p1.x-p2.x) + (p1.z-p2.z)*(p1.z-p2.z));
}

float W_POLY6(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position);
    return ALPHA_POLY6 * K_POLY6(r);
}

float W_POLY6(float3 p1, float3 p2){
    float r = KernelDistance(p1, p2);
    return ALPHA_POLY6 * K_POLY6(r);
}

float3 W_POLY6_Grad(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position);
    if(r==0) return float3(0,0,0);
    return ALPHA_POLY6 * K_POLY6_Prime(r) * (p1._Position - p2._Position) / r;
}

float W_POLY6_Derivated(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position);
    return ALPHA_POLY6 * K_POLY6_Prime(r);
}

float W_POLY6_Lap(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position);
    return ALPHA_POLY6_LAPLACIAN * K_POLY6_Lap(r);
}

float W_VISCOSITY(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position);
    return ALPHA_VISCOSITY * K_VISCOSITY(r);
}

float3 W_VISCOSITY_Grad(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position);
    float prime = K_VISCOSITY_Prime(r);
    float3 pos = (p1._Position - p2._Position);
    return ALPHA_VISCOSITY * prime * pos;
}

float W_VISCOSITY_Lap(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position);
    float l = H;
    return ALPHA_VISCOSITY_LAPLACIAN*(l-r);
}

// ##################################################################################################################
// ############################################ SPH FUNCTIONS #######################################################
// ##################################################################################################################
ParticleGPU GetParticle(uint3 id : SV_DispatchThreadID){
    return _Particles[id.x];
}

ParticleGPU GetParticle(uint id){
    return _Particles[id];
}

bool AreNeighbours(ParticleGPU pi, ParticleGPU pj){
    return KernelDistance(pi._Position, pj._Position) < H;
}

bool AreNeighbours(float3 pi, float3 pj){
    return KernelDistance(pi, pj) < H;
}


float3 GetGradientSurface(ParticleGPU pi){
    return StaggeredGridGetGradient(pi) + pi._HeightGradient;
    // return float3(StaggeredGridGetGradient(pi).x, 0, 0);
}

bool IsUpTerrainBorder(uint3 id : SV_DispatchThreadID){
    return id.x >= _StaggeredGrid[0]._NbCols * (_StaggeredGrid[0]._NbLines - 1);
}
bool IsDownTerrainBorder(uint3 id : SV_DispatchThreadID){
    return id.x < _StaggeredGrid[0]._NbCols;
}
bool IsLeftTerrainBorder(uint3 id : SV_DispatchThreadID){
    return id.x % _StaggeredGrid[0]._NbCols == 0;
}
bool IsRightTerrainBorder(uint3 id : SV_DispatchThreadID){
    return id.x % _StaggeredGrid[0]._NbCols == _StaggeredGrid[0]._NbLines - 1;
}

uint GetUpLeftTerrain(uint3 id : SV_DispatchThreadID){
    return id.x + _StaggeredGrid[0]._NbCols - 1;
}
uint GetUpMiddleTerrain(uint3 id : SV_DispatchThreadID){
    return id.x + _StaggeredGrid[0]._NbCols;
}
uint GetUpRightTerrain(uint3 id : SV_DispatchThreadID){
    return id.x + _StaggeredGrid[0]._NbCols + 1;
}

uint GetMiddleLeftTerrain(uint3 id : SV_DispatchThreadID){
    return id.x - 1;
}
uint GetMiddleMiddleTerrain(uint3 id : SV_DispatchThreadID){
    return id.x;
}
uint GetMiddleRightTerrain(uint3 id : SV_DispatchThreadID){
    return id.x + 1;
}

uint GetDownLeftTerrain(uint3 id : SV_DispatchThreadID){
    return id.x - _StaggeredGrid[0]._NbCols - 1;
}
uint GetDownMiddleTerrain(uint3 id : SV_DispatchThreadID){
    return id.x - _StaggeredGrid[0]._NbCols;
}
uint GetDownRightTerrain(uint3 id : SV_DispatchThreadID){
    return id.x - _StaggeredGrid[0]._NbCols + 1;
}

[numthreads(1024,1,1)]
void GaussianBlurTerrainHeights(uint3 id : SV_DispatchThreadID){
    float w11 = IsUpTerrainBorder(id) || IsLeftTerrainBorder(id) ? 0.0f : _TerrainHeightsTmp[GetUpLeftTerrain(id)];
    float w12 = IsUpTerrainBorder(id) ? 0.0f : _TerrainHeightsTmp[GetUpMiddleTerrain(id)];
    float w13 = IsUpTerrainBorder(id) || IsRightTerrainBorder(id) ? 0.0f : _TerrainHeightsTmp[GetUpRightTerrain(id)];
    float w21 = IsLeftTerrainBorder(id) ? 0.0f : _TerrainHeightsTmp[GetMiddleLeftTerrain(id)];
    float w22 = _TerrainHeightsTmp[GetMiddleMiddleTerrain(id)];
    float w23 = IsRightTerrainBorder(id) ? 0.0f : _TerrainHeightsTmp[GetMiddleRightTerrain(id)];
    float w31 = IsDownTerrainBorder(id) || IsLeftTerrainBorder(id)  ? 0.0f : _TerrainHeightsTmp[GetDownLeftTerrain(id)];
    float w32 = IsDownTerrainBorder(id) || IsLeftTerrainBorder(id)  ? 0.0f : _TerrainHeightsTmp[GetDownMiddleTerrain(id)];
    float w33 = IsDownTerrainBorder(id) || IsLeftTerrainBorder(id)  ? 0.0f : _TerrainHeightsTmp[GetDownRightTerrain(id)];

    float GaussFactor = 1.0f/16.0f;
    float GaussMatrix[9] = {1, 2, 1, 2, 4, 2, 1, 2, 1};

    float res =   w11*GaussMatrix[0]*GaussFactor + w12*GaussMatrix[1]*GaussFactor + w13*GaussMatrix[2]*GaussFactor
                + w21*GaussMatrix[3]*GaussFactor + w22*GaussMatrix[4]*GaussFactor + w23*GaussMatrix[5]*GaussFactor
                + w31*GaussMatrix[6]*GaussFactor + w32*GaussMatrix[7]*GaussFactor + w33*GaussMatrix[8]*GaussFactor;

    if(GaussFactor == 0.0f)
        res = w22;

    if(FirstTimeBlur) _InitialTerrainHeights[id.x] = res;
    // _TerrainHeights[id.x] = res;
}

float3 GenRandomPos(float3 pos, uint id){
    return float3(sin(RAND + id)+pos.x, pos.y, -cos(RAND+id)+pos.z);
}



// ##################################################################################################################
// ############################################ Neighbours FUNCTIONS #######################################################
// ##################################################################################################################

uint GetCell(float3 pos){
    uint posX = (uint)(pos.x / _NeighbourGrid[0]._DeltaCols);
    uint posZ = (uint)(pos.z / _NeighbourGrid[0]._DeltaLines);
    return ((posZ*_NeighbourGrid[0]._NbCols + posX)*_NeighbourGrid[0]._NbMaxNeighbours);
}

uint CellIdToCellCountId(uint cellId){
    uint j = (uint)(cellId/(_NeighbourGrid[0]._NbMaxNeighbours*_NeighbourGrid[0]._NbCols));
    uint i = (uint)((cellId-_NeighbourGrid[0]._NbMaxNeighbours*j*_NeighbourGrid[0]._NbCols)/_NeighbourGrid[0]._NbMaxNeighbours);
    return j*_NeighbourGrid[0]._NbCols + i;
}

uint GetCellCount(uint cellId){
    return _NeighbourGridCellsCounter[CellIdToCellCountId(cellId)];
}

bool IsUpNeighbourBorder(uint cellId){
    return cellId >= (_NeighbourGrid[0]._NbCols * (_NeighbourGrid[0]._NbLines - 1))*_NeighbourGrid[0]._NbMaxNeighbours;
}
bool IsDownNeighbourBorder(uint cellId){
    return cellId < (_NeighbourGrid[0]._NbCols)*_NeighbourGrid[0]._NbMaxNeighbours;
}
bool IsLeftNeighbourBorder(uint cellId){
    return cellId % (_NeighbourGrid[0]._NbCols*_NeighbourGrid[0]._NbMaxNeighbours) == 0;
}
bool IsRightNeighbourBorder(uint cellId){
    return cellId % (_NeighbourGrid[0]._NbCols*_NeighbourGrid[0]._NbMaxNeighbours) == (_NeighbourGrid[0]._NbLines - 1)*_NeighbourGrid[0]._NbMaxNeighbours;
}

int GetUpLeftNeighbour(uint id){
    if(IsUpNeighbourBorder(id) || IsLeftNeighbourBorder(id)) return -1;
    return id + (_NeighbourGrid[0]._NbCols - 1)*_NeighbourGrid[0]._NbMaxNeighbours;
}
int GetUpMiddleNeighbour(uint id){
    if(IsUpNeighbourBorder(id)) return -1;
    return id + (_NeighbourGrid[0]._NbCols)*_NeighbourGrid[0]._NbMaxNeighbours;
}
int GetUpRightNeighbour(uint id){
    if(IsUpNeighbourBorder(id) || IsRightNeighbourBorder(id)) return -1;
    return id + (_NeighbourGrid[0]._NbCols + 1)*_NeighbourGrid[0]._NbMaxNeighbours;
}

int GetMiddleLeftNeighbour(uint id){
    if(IsLeftNeighbourBorder(id)) return -1;
    return id - (1)*_NeighbourGrid[0]._NbMaxNeighbours;
}
int GetMiddleMiddleNeighbour(uint id){
    return id;
}
int GetMiddleRightNeighbour(uint id){
    if(IsRightNeighbourBorder(id)) return -1;
    return id + (1)*_NeighbourGrid[0]._NbMaxNeighbours;
}

int GetDownLeftNeighbour(uint id){
    if(IsDownNeighbourBorder(id) || IsLeftNeighbourBorder(id)) return -1;
    return id - (_NeighbourGrid[0]._NbCols - 1)*_NeighbourGrid[0]._NbMaxNeighbours;
}
int GetDownMiddleNeighbour(uint id){
    if(IsDownNeighbourBorder(id)) return -1;
    return id - (_NeighbourGrid[0]._NbCols)*_NeighbourGrid[0]._NbMaxNeighbours;
}
int GetDownRightNeighbour(uint id){
    if(IsDownNeighbourBorder(id) || IsRightNeighbourBorder(id)) return -1;
    return id - (_NeighbourGrid[0]._NbCols + 1)*_NeighbourGrid[0]._NbMaxNeighbours;
}


// ##################################################################################################################
// ############################################ Kernel FUNCTIONS #######################################################
// ##################################################################################################################
[numthreads(128,1,1)]
void PropagateDensityUpdate(uint3 id : SV_DispatchThreadID){
    if(id.x >= _NbCurParticles) return;
    ParticleGPU pi = GetParticle(id);
    pi._Density = _Densities[id.x];
    pi._Volume  = _Volumes[id.x];
    _Particles[id.x] = pi;
}

[numthreads(128,1,1)]
void PropagateHeightUpdate(uint3 id : SV_DispatchThreadID){
    if(id.x >= _NbCurParticles) return;
    ParticleGPU pi = GetParticle(id);
    pi._Height         = _Heights[id.x];
    pi._HeightGradient = _HeightsGradients[id.x];
    _Particles[id.x] = pi;
}

[numthreads(128,1,1)]
void PropagatePositionUpdate(uint3 id : SV_DispatchThreadID){
    if(id.x >= _NbCurParticles) return;
    ParticleGPU pi = GetParticle(id);
    float3 newPosition = _Positions[id.x];
    pi._Position = newPosition;
    pi._Cell = GetCell(newPosition);
    _Particles[id.x] = pi;
}

[numthreads(1024,1,1)]
void ResetNeighboursCounter(uint3 id : SV_DispatchThreadID){\
    if(id.x>=_NeighbourGrid[0]._NbLines*_NeighbourGrid[0]._NbCols) return;
    _NeighbourGridCellsCounter[id.x] = 0;
}

[numthreads(1024,1,1)]
void UpdateNeighbours(uint3 id : SV_DispatchThreadID){
    if(id.x >= _NeighbourGrid[0]._NbCols*_NeighbourGrid[0]._NbLines) return;
    
    uint cpt = 0;
    uint cellId = id.x*_NeighbourGrid[0]._NbMaxNeighbours;

    for(uint j=0; j<_NbCurParticles; j++){
        ParticleGPU pj = GetParticle(j);
        uint idx = pj._Cell;

        if(idx == cellId){
            _NeighbourGridCells[cellId+cpt] = pj._Id;
            cpt++;
            if(cpt >= _NeighbourGrid[0]._NbMaxNeighbours) break;
        } 
    }
    _NeighbourGridCellsCounter[id.x] = cpt;
}

[numthreads(128,1,1)]
void GenerateParticle(uint3 id : SV_DispatchThreadID){
    if(id.x < _NbNewParticles){
        uint i = (_NbCurParticles - 1 - id.x);

        float density = RHO_0;
        // float mass = H*H*H*RHO_0; // Ihmsen et al 2013
        float a = (2.0/3.0)*H;
        float mass = a*a*a*RHO_0;
        float volume = mass / density;

        float radius = pow(abs((3*volume / (4*PI))), (1.0f/3.0f));

        ParticleGPU p; 
        float3 pos = GenRandomPos(_NewPosition, id.x);
        p._Velocity = float3(0.0f,0.0f,0.0f);
        p._Position = pos;
        // p._Height = radius / 2.0f;
        p._Height = _ParticleInitialHeight,
        p._HeightGradient = float3(0,0,0);
        p._Density = density;
        p._Mass = mass;
        p._Volume = volume;
        p._Temperature = _Ke;
        // p._Cell = 0;
        p._Cell = GetCell(pos);
        p._Id = i;
        
        _Velocities[i]       = p._Velocity;
        _Positions[i]        = p._Position;
        _Heights[i]          = p._Height;
        _HeightsGradients[i] = p._HeightGradient;
        _Volumes[i]          = p._Volume;
        _Temperatures[i]     = p._Temperature;
        _Particles[i]        = p;
    }
}


void UpdateTerrainDensitiesMinMax(uint id, uint maxIdx, float h){
    float3 pos = StaggeredGridGetPosition(id);

    // get number of cells arround me that are inside kernel
    int nbCells = h / _StaggeredGrid[0]._DeltaCols + 1;

    float densityMin = -1.0f;
    float densityMax = -1.0f;

    // check cells inside radius
    for(int j=-nbCells; j<=nbCells; j++){
        for(int i=-nbCells; i<=nbCells; i++){
            int curCell = id + i + (j*_StaggeredGrid[0]._NbCols);
            
            // do not count cells outside the grid
            if(curCell < 0 || curCell >= (int)maxIdx) continue;

            // update min and max densities
            float curDensity = _TerrainDensities[(uint)curCell];
            if(densityMin < 0 || curDensity < densityMin){
                densityMin = curDensity;
            }
            if(densityMax < 0 || curDensity > densityMax){
                densityMax = curDensity;
            }
        }
    }

    _TerrainDensitiesMinMax[id] = float2(densityMin, densityMax);
}

void UpdateDensitiesStar(uint id){
    float density    = _TerrainDensities[id];
    float densityHat = _TerrainDensitiesHat[id];
    float densityMin = _TerrainDensitiesMinMax[id].x;
    float densityMax = _TerrainDensitiesMinMax[id].y;
    
    if(densityMax == densityMin){
        _TerrainDensitiesStar[id] = 0.0f;
        return;
    }

    float alpha = (density-densityMin) / (densityMax-densityMin);
    // if((density-densityMin)<0) alpha = 0;
    float densityStar = alpha*densityHat + (1-alpha)*density;

    _TerrainDensitiesStar[id] = densityStar;
}

[numthreads(1024,1,1)]
void UpdateTerrainDensitiesStar(uint3 id : SV_DispatchThreadID){
    uint maxIdx = _StaggeredGrid[0]._NbCols * _StaggeredGrid[0]._NbLines;
    if(id.x >= maxIdx) return;
    float h = _TerrainDensitiesRadii[id.x];
    UpdateTerrainDensitiesMinMax(id.x, maxIdx, h);
    UpdateDensitiesStar(id.x);
}

float W_POLY6_Densities(float3 p1, float3 p2, float h){
    float r = KernelDistance(p1, p2);
    if(r<0 || r>h) return 0.0f;
    float alpha = 4/(PI*h*h*h*h*h*h*h*h);
    float tmp = (h*h - r*r);
    return alpha*tmp*tmp*tmp;
}

float GetKernelRadius(float density, float hMin, float hMax){
    if(density < _TerrainDensityMin || density > _TerrainDensityMax) return H;
    float a = (hMax-hMin) / (_TerrainDensityMax - _TerrainDensityMin);
    float b = hMin - a*_TerrainDensityMin;
    return a*density + b;
}

[numthreads(1024,1,1)]
void UpdateTerrainDensities(uint3 id : SV_DispatchThreadID){
    if(id.x >= _StaggeredGrid[0]._NbCols * _StaggeredGrid[0]._NbLines) return;
    float3 pos = StaggeredGridGetPosition(id.x);

    float sumDensities = 0.0f;
    float sumWeights = 0.0f;

    float kernelRadius = GetKernelRadius(_TerrainDensities[id.x], H, 3*H);
    // float kernelRadius = 10*H;
    // float kernelRadius = H;
    
    uint cellIdx = GetCell(pos);
    int w11 = GetUpLeftNeighbour(cellIdx);
    int w12 = GetUpMiddleNeighbour(cellIdx);
    int w13 = GetUpRightNeighbour(cellIdx);
    int w21 = GetMiddleLeftNeighbour(cellIdx);
    int w22 = GetMiddleMiddleNeighbour(cellIdx);
    int w23 = GetMiddleRightNeighbour(cellIdx);
    int w31 = GetDownLeftNeighbour(cellIdx);
    int w32 = GetDownMiddleNeighbour(cellIdx);
    int w33 = GetDownRightNeighbour(cellIdx);
    int cells[9] = {w11, w12, w13,
                    w21, w22, w23,
                    w31, w32, w33};

    for(uint i=0; i<9; i++){
        int idx = cells[i];
        // int idx = cellIdx;
        if(idx <= -1) continue;
        // uint cpt = 1;
        uint cpt = GetCellCount(idx);

        for(uint j=0; j<cpt; j++){
            ParticleGPU pj = GetParticle(_NeighbourGridCells[idx+j]);
            // ParticleGPU pj = GetParticle(0);
            if(!AreNeighbours(pos, pj._Position)) continue;

            float wij = W_POLY6_Densities(pos, pj._Position, kernelRadius);
            // TODO:
            sumDensities += wij*pj._Height;
            // sumDensities = 1;
            sumWeights += wij;
            // sumWeights = 1;
        }
    }

    _TerrainDensitiesRadii[id.x] = kernelRadius;
    _TerrainDensities[id.x] = sumDensities;
    _TerrainDensitiesHat[id.x] = sumWeights < 0.0001f ? 0.0f : sumDensities / sumWeights;
}

[numthreads(1024,1,1)]
void UpdateTerrainHeights(uint3 id : SV_DispatchThreadID){
    if(id.x >= _StaggeredGrid[0]._NbCols * _StaggeredGrid[0]._NbLines) return;
    
    // TODO:
    float newHeight = SPIKE*(_TerrainDensitiesStar[id.x] / RHO_0) + _InitialTerrainHeights[id.x];
    // float newHeight = SPIKE*(_TerrainDensities[id.x]) + _InitialTerrainHeights[id.x];
    // float newHeight = SPIKE*(_TerrainDensitiesHat[id.x]) + _InitialTerrainHeights[id.x];
    
    _TerrainHeightsTmp[id.x] = newHeight;
    _TerrainHeights[id.x] = newHeight;
    if(!_DisplayLava) _TerrainHeights[id.x] = _InitialTerrainHeights[id.x];
    // if(!GaussianBlur) _TerrainHeights[id.x] = newHeight;
}


[numthreads(128,1,1)]
void UpdateDensities(uint3 id : SV_DispatchThreadID){
    if(id.x >= _NbCurParticles) return;
    ParticleGPU pi = GetParticle(id);

    float sumDensity = 0.0f;
    // int cpt = 0;

    for(uint j=0; j<_NbCurParticles; j++){
        ParticleGPU pj = GetParticle(j);
        if(!AreNeighbours(pi,pj)) continue;

        float wijMass = W_POLY6(pi, pj);
        sumDensity += wijMass * pj._Volume / pj._Height;
        // TODO:
        // _Positions[id.x] = wijMass > 0.99 && wijMass < 1.01 ? _Positions[id.x] : float3(0,0,0);
        // cpt++;
    }

    _Densities[id.x] = sumDensity;
    // _Volumes[id.x] = pi._Mass / sumMasses;
}

[numthreads(128,1,1)]
void UpdateHeights(uint3 id : SV_DispatchThreadID){
    if(id.x >= _NbCurParticles) return;
    ParticleGPU pi = GetParticle(id);

    float sumHeights = 0.0f;
    // float sumWeights = 0.0f;
    
    float3 sumGrads  = float3(0.0f, 0.0f, 0.0f);

    uint cellIdx = GetCell(pi._Position);
    int w11 = GetUpLeftNeighbour(cellIdx);
    int w12 = GetUpMiddleNeighbour(cellIdx);
    int w13 = GetUpRightNeighbour(cellIdx);
    int w21 = GetMiddleLeftNeighbour(cellIdx);
    int w22 = GetMiddleMiddleNeighbour(cellIdx);
    int w23 = GetMiddleRightNeighbour(cellIdx);
    int w31 = GetDownLeftNeighbour(cellIdx);
    int w32 = GetDownMiddleNeighbour(cellIdx);
    int w33 = GetDownRightNeighbour(cellIdx);
    int cells[9] = {w11, w12, w13,
                    w21, w22, w23,
                    w31, w32, w33};

    for(uint i=0; i<9; i++){
        int idx = cells[i];
        // int idx = cellIdx;
        if(idx <= -1) continue;
        // uint cpt = 1;
        uint cpt = GetCellCount(idx);

        for(uint j=0; j<cpt; j++){
            ParticleGPU pj = GetParticle(_NeighbourGridCells[idx+j]);
            if(!AreNeighbours(pi,pj)) continue;

            float  wijHeight = W_POLY6(pi, pj);
            float3 wijGrad   = W_POLY6_Grad(pi, pj);

            sumHeights += wijHeight * pj._Volume;
            sumGrads   += wijGrad * pj._Volume;
            // sumWeights += wijHeight;
        }
    }

    _Heights[id.x] = sumHeights;
    _HeightsGradients[id.x] = sumGrads;
}

[numthreads(128,1,1)]
void TimeIntegration(uint3 id : SV_DispatchThreadID){
    if(id.x >= _NbCurParticles) return;
    ParticleGPU pi = GetParticle(id);

    float3 curPosition = pi._Position;
    float3 newVelocity = pi._Velocity;
    // if(newVelocity.x <= 0.0001f && newVelocity.z <= 0.0001f) newVelocity = float3(-1,0,0);
    float3 newPosition = (DT/STIFF)*newVelocity + curPosition;

    newPosition.y = StaggeredGridGetHeight(newPosition);

    // TODO:
    // if(curPosition.x <= 1e-6 && curPosition.z <= 1e-6) newPosition = float3(256, StaggeredGridGetHeight(float3(256, 0, 256)), 256);
    _Positions[id.x] = newPosition;
    // _Positions[id.x] = curPosition;
}


// ##################################################################################################################
// ############################################ Viscosity FUNCTIONS #######################################################
// ##################################################################################################################
[numthreads(128,1,1)]
void UpdateTemperatures(uint3 id : SV_DispatchThreadID){
    if(id.x >= _NbCurParticles) return;
    ParticleGPU pi = GetParticle(id);

    float sumTemperatures = 0.0f;

    uint cellIdx = GetCell(pi._Position);
    int w11 = GetUpLeftNeighbour(cellIdx);
    int w12 = GetUpMiddleNeighbour(cellIdx);
    int w13 = GetUpRightNeighbour(cellIdx);
    int w21 = GetMiddleLeftNeighbour(cellIdx);
    int w22 = GetMiddleMiddleNeighbour(cellIdx);
    int w23 = GetMiddleRightNeighbour(cellIdx);
    int w31 = GetDownLeftNeighbour(cellIdx);
    int w32 = GetDownMiddleNeighbour(cellIdx);
    int w33 = GetDownRightNeighbour(cellIdx);
    int cells[9] = {w11, w12, w13,
                    w21, w22, w23,
                    w31, w32, w33};

    for(uint i=0; i<9; i++){
        int idx = cells[i];
        // int idx = cellIdx;
        if(idx <= -1) continue;
        // uint cpt = 1;
        uint cpt = GetCellCount(idx);

        for(uint j=0; j<cpt; j++){
            ParticleGPU pj = GetParticle(_NeighbourGridCells[idx+j]);
            if(!AreNeighbours(pi,pj)) continue;

            float  wij = W_POLY6(pi, pj);

            sumTemperatures += pj._Temperature * wij * pj._Volume / pj._Height;
        }
    }

    _Temperatures[id.x] = sumTemperatures;
}

[numthreads(128,1,1)]
void PropagateTemperatureUpdate(uint3 id : SV_DispatchThreadID){
    if(id.x >= _NbCurParticles) return;
    ParticleGPU pi = GetParticle(id);
    pi._Temperature = _Temperatures[id.x];
    _Particles[id.x] = pi;
}


float K_NEW(float rTmp){
    float r = rTmp < 0.001f ? 0.001f : rTmp;
    if(r<=H) {
        float gamma = 0.577216;
        return (-log(r)-gamma+log(2)) + (1.0f/4.0f)*r*r*(-log(r)-gamma+1+log(2));
    }
    else return 0.0f;
}

float W_NEW(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position);
    float k = sqrt(3.0f/2.0f)*(1.0f/p2._Height);
    return (2/(PI*H*H))* K_POLY6(k*r);
}

float FTemp(float theta){
    return _Ke*exp(ALPHA*(_ThetaE-theta));
}

[numthreads(128,1,1)]
void UpdateVelocities(uint3 id : SV_DispatchThreadID){
    if(id.x >= _NbCurParticles) return;
    ParticleGPU pi = GetParticle(id);

    float3 sumVelocities = float3(0.0f,0.0f,0.0f);
    float  sumWeights = 0.0f;

    uint cellIdx = GetCell(pi._Position);
    int w11 = GetUpLeftNeighbour(cellIdx);
    int w12 = GetUpMiddleNeighbour(cellIdx);
    int w13 = GetUpRightNeighbour(cellIdx);
    int w21 = GetMiddleLeftNeighbour(cellIdx);
    int w22 = GetMiddleMiddleNeighbour(cellIdx);
    int w23 = GetMiddleRightNeighbour(cellIdx);
    int w31 = GetDownLeftNeighbour(cellIdx);
    int w32 = GetDownMiddleNeighbour(cellIdx);
    int w33 = GetDownRightNeighbour(cellIdx);
    int cells[9] = {w11, w12, w13,
                    w21, w22, w23,
                    w31, w32, w33};

    for(uint i=0; i<9; i++){
        int idx = cells[i];
        // int idx = cellIdx;
        if(idx <= -1) continue;
        // uint cpt = 1;
        uint cpt = GetCellCount(idx);

        for(uint j=0; j<cpt; j++){
            ParticleGPU pj = GetParticle(_NeighbourGridCells[idx+j]);
            if(!AreNeighbours(pi,pj)) continue;

            float f_theta = FTemp(pj._Temperature);
            float mu = _Mu;
            float rho = pj._Density;
            float3 gradSurface = GetGradientSurface(pj);

            float3 b = -(rho*G)/(f_theta*mu)*gradSurface;
            // float3 b = -(rho*G)/(mu)*gradSurface;
            float wij = W_NEW(pi, pj);

            sumVelocities += wij*b;
            sumWeights += wij;
        }
    }

    // _Velocities[id.x] = sumVelocities / sumWeights;
    _Velocities[id.x] = sumVelocities;
}

[numthreads(128,1,1)]
void PropagateVelocityUpdate(uint3 id : SV_DispatchThreadID){
    if(id.x >= _NbCurParticles) return;
    ParticleGPU pi = GetParticle(id);
    pi._Velocity = _Velocities[id.x];
    _Particles[id.x] = pi;
}