// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GenerateParticle
#pragma kernel UpdateHeights
#pragma kernel PropagateHeights
#pragma kernel TimeIntegration
#pragma kernel PropagatePositions
#pragma kernel UpdateTerrainHeights

uniform float H;
uniform float PI;
uniform float G;

uniform float STIFF;
uniform float RHO_0;

uniform float ALPHA_POLY6;
uniform float ALPHA_POLY6_LAPLACIAN;
uniform float ALPHA_VISCOSITY;
uniform float ALPHA_VISCOSITY_LAPLACIAN;

uniform float SPIKE;
uniform uint MAX_PARTICLES;
uniform uint _NbCurParticles;

uniform float DT;

struct StaggeredGridGPU{
    uint _NbCols, _NbLines;
    float _DeltaCols, _DeltaLines;
};

struct ParticleGPU{
    float3 _Position;
    float  _Height;
    float3 _HeightGradient;
    float  _Volume;
};

uniform StructuredBuffer<StaggeredGridGPU> _StaggeredGrid;
uniform StructuredBuffer<float>  _StaggeredGridHeights;
uniform StructuredBuffer<float>  _StaggeredGridHalfHeightsCols;
uniform StructuredBuffer<float>  _StaggeredGridHalfHeightsLines;
uniform StructuredBuffer<float>  _StaggeredGridHalfHeights;
uniform StructuredBuffer<float2> _StaggeredGridGradients;
uniform StructuredBuffer<float>  _StaggeredGridLaplacians;

RWStructuredBuffer<float> _TerrainHeights;

RWStructuredBuffer<ParticleGPU> _Particles;
RWStructuredBuffer<float3> _Positions;
RWStructuredBuffer<float>  _Heights;
RWStructuredBuffer<float3> _HeightsGradients;
RWStructuredBuffer<float>  _Volumes;

uniform StructuredBuffer<ParticleGPU> _NewParticle;

// ##################################################################################################################
// ################################### STAGGERED GRID ###############################################################
// ##################################################################################################################
uint StaggeredGridConvertIndices(uint posZ, uint posX){
    return posX + posZ * _StaggeredGrid[0]._NbCols;
}

uint2 StaggeredGridGetIndices(float3 pos){
    uint posX = (uint)(pos.x / _StaggeredGrid[0]._DeltaCols);
    uint posZ = (uint)(pos.z / _StaggeredGrid[0]._DeltaLines);
    return uint2(posZ, posX);
};

float3 StaggeredGridGetPosition(uint id){
    uint yId = id / _StaggeredGrid[0]._NbCols;
    uint xId = id - yId * _StaggeredGrid[0]._NbCols;

    float x = xId*_StaggeredGrid[0]._DeltaCols;
    float y = _StaggeredGridHeights[id];
    float z = yId*_StaggeredGrid[0]._DeltaLines;
    
    return float3(x,y,z);
}

float StaggeredGridBilinearInterpolation(float x, float z, float xIdx, float zIdx, float w11, float w12, float w21, float w22){
    float xLeft  = xIdx*_StaggeredGrid[0]._DeltaCols;
    float xRight = (xIdx+1)*_StaggeredGrid[0]._DeltaCols;
    float zUp    = (zIdx+1)*_StaggeredGrid[0]._DeltaLines;
    float zDown  = zIdx*_StaggeredGrid[0]._DeltaLines;

    float x2_prime = xRight - x;
    float x1_prime = x - xLeft;
    float z2_prime = zUp - z;
    float z1_prime = z - zDown;

    float factor = 1.0/(_StaggeredGrid[0]._DeltaCols*_StaggeredGrid[0]._DeltaLines);


    float res = ((w11*x2_prime + w21*x1_prime)*z2_prime) + ((w12*x2_prime + w22*x1_prime)*z1_prime);

    return res *= factor;
}

float StaggeredGridGetHeight(float3 pos){
    uint2 indices = StaggeredGridGetIndices(pos);
    uint zIdx = indices[0];
    uint xIdx = indices[1];

    float x = pos.x;
    float z = pos.z;

    // interpolate height, bilinearly
    float upLeft    = (zIdx >= _StaggeredGrid[0]._NbLines-1 || xIdx <= 0)                           ? 0.0f : _StaggeredGridHalfHeights[StaggeredGridConvertIndices(zIdx, xIdx-1)];
    float upRight   = (zIdx >= _StaggeredGrid[0]._NbLines-1 || xIdx >= _StaggeredGrid[0]._NbCols-1) ? 0.0f : _StaggeredGridHalfHeights[StaggeredGridConvertIndices(zIdx, xIdx)];
    float downLeft  = (zIdx <= 0 || xIdx <= 0)                                                      ? 0.0f : _StaggeredGridHalfHeights[StaggeredGridConvertIndices(zIdx-1, xIdx-1)];
    float downRight = (zIdx <= 0 || xIdx >= _StaggeredGrid[0]._NbCols-1)                            ? 0.0f : _StaggeredGridHalfHeights[StaggeredGridConvertIndices(zIdx-1, xIdx)];

    float ownRes = StaggeredGridBilinearInterpolation(x, z, xIdx, zIdx, downLeft, upLeft, downRight, upRight);
    return ownRes;
}

float3 StaggeredGridGetGradient(ParticleGPU p){
    float3 pos = p._Position;
    uint2 indices = StaggeredGridGetIndices(pos);
    uint zIdx = indices[0];
    uint xIdx = indices[1];

    float x = pos.x;
    float z = pos.z;

    // interpolate gradients bilinearly
    float2 upLeft    = (zIdx >= _StaggeredGrid[0]._NbLines-1 || xIdx <= 0)                           ? float2(0.0f, 0.0f) : _StaggeredGridGradients[StaggeredGridConvertIndices(zIdx, xIdx-1)];
    float2 upRight   = (zIdx >= _StaggeredGrid[0]._NbLines-1 || xIdx >= _StaggeredGrid[0]._NbCols-1) ? float2(0.0f, 0.0f) : _StaggeredGridGradients[StaggeredGridConvertIndices(zIdx, xIdx)];
    float2 downLeft  = (zIdx <= 0 || xIdx <= 0)                                                      ? float2(0.0f, 0.0f) : _StaggeredGridGradients[StaggeredGridConvertIndices(zIdx-1, xIdx-1)];
    float2 downRight = (zIdx <= 0 || xIdx >= _StaggeredGrid[0]._NbCols-1)                            ? float2(0.0f, 0.0f) : _StaggeredGridGradients[StaggeredGridConvertIndices(zIdx-1, xIdx)];

    float dx, dz;

    dx = StaggeredGridBilinearInterpolation(x, z, xIdx, zIdx, downLeft.x, upLeft.x, downRight.x, upRight.x);
    dz = StaggeredGridBilinearInterpolation(x, z, xIdx, zIdx, downLeft.y, upLeft.y, downRight.y, upRight.y);
    // TODO: restore it
    if(xIdx >= _StaggeredGrid[0]._NbCols-1 || zIdx >= _StaggeredGrid[0]._NbLines-1){
        dx = 0.0f;
        dz = 0.0f;
    } else {
        dx = _StaggeredGridGradients[StaggeredGridConvertIndices(zIdx, xIdx)].x;
        dz = _StaggeredGridGradients[StaggeredGridConvertIndices(zIdx, xIdx)].y;
    }

    return float3(dx, pos.y, dz);
}

float StaggeredGridGetLaplacian(float3 pos){
    uint2 indices = StaggeredGridGetIndices(pos);
    uint zIdx = indices[0];
    uint xIdx = indices[1];

    float x = pos.x;
    float z = pos.z;

    // interpolate gradients bilinearly
    float upLeft    = (zIdx >= _StaggeredGrid[0]._NbLines-2 || xIdx <= 1)                           ? 0.0f : _StaggeredGridLaplacians[StaggeredGridConvertIndices(zIdx-2+1, xIdx-2+0)];
    float upRight   = (zIdx >= _StaggeredGrid[0]._NbLines-2 || xIdx >= _StaggeredGrid[0]._NbCols-2) ? 0.0f : _StaggeredGridLaplacians[StaggeredGridConvertIndices(zIdx-2+1, xIdx-2+1)];
    float downLeft  = (zIdx <= 1 || xIdx <= 1)                                                      ? 0.0f : _StaggeredGridLaplacians[StaggeredGridConvertIndices(zIdx-2+0, xIdx-2+0)];
    float downRight = (zIdx <= 1 || xIdx >= _StaggeredGrid[0]._NbCols-1)                            ? 0.0f : _StaggeredGridLaplacians[StaggeredGridConvertIndices(zIdx-2+0, xIdx-2+1)];

    float ownRes = StaggeredGridBilinearInterpolation(x, z, xIdx, zIdx, upLeft, upRight, downLeft, downRight);
    return ownRes;
}



// ##################################################################################################################
// ############################################### KERNEL ###########################################################
// ##################################################################################################################
float K_POLY6(float r){
    if(r<H) {
        float tmp = (H*H-r*r);
        return tmp*tmp*tmp;
    }
    else return 0.0f;
}


float K_POLY6_Prime(float r){
    if(r<H) {
        float tmp = ((H*H)-r*r);
        return -6.0f*r*tmp*tmp;
    }
    else return 0.0f;    
}

float K_POLY6_Lap(float r){
    if(r<H) {
        float tmp = ((H*H)-r*r);
        return tmp*(2*r*r-H*H);
    }
    else return 0.0f;
}

float K_VISCOSITY(float r){
    float l = H;
    if(r<l) {
        return r*r*(-4.0f*r + 9.0f*l) + l*l*l*(-5.0f + 6.0f*(log(l)-log(r)));
    }
    else return 0.0f;
}

float K_VISCOSITY_Prime(float r){
    float l = H;
    if(r<l) {
        if(r != 0) return r*(-12.0f*r + 18.0f*l) - (6.0f*l*l*l) / r;
        return 0.0f;
    }
    else return 0.0f;
}

float KernelDistance(float3 p1, float3 p2){
    return sqrt((p1.x-p2.x)*(p1.x-p2.x) + (p1.z-p2.z)*(p1.z-p2.z));
}

float W_POLY6(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position) / H;
    return ALPHA_POLY6 * K_POLY6(r);
}

float W_POLY6(float3 p1, float3 p2){
    float r = KernelDistance(p1, p2) / H;
    return ALPHA_POLY6 * K_POLY6(r);
}

float3 W_POLY6_Grad(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position) / H;
    return ALPHA_POLY6 * K_POLY6_Prime(r) * (p1._Position - p2._Position);
}

float W_POLY6_Derivated(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position) / H;
    return ALPHA_POLY6 * K_POLY6_Prime(r);
}

float W_POLY6_Lap(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position) / H;
    return ALPHA_POLY6_LAPLACIAN * K_POLY6_Lap(r);
}

float W_VISCOSITY(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position) / H;
    return ALPHA_VISCOSITY * K_VISCOSITY(r);
}

float3 W_VISCOSITY_Grad(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position) / H;
    float prime = K_VISCOSITY_Prime(r);
    float3 pos = (p1._Position - p2._Position);
    return ALPHA_VISCOSITY * prime * pos;
}

float W_VISCOSITY_Lap(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position) / H;
    float l = H;
    return ALPHA_VISCOSITY_LAPLACIAN*(l-r);
}

// ##################################################################################################################
// ############################################ SPH FUNCTIONS #######################################################
// ##################################################################################################################
ParticleGPU GetParticle(uint3 id : SV_DispatchThreadID){
    return _Particles[id.x];
}

ParticleGPU GetParticle(uint id){
    return _Particles[id];
}

bool AreNeighbours(ParticleGPU pi, ParticleGPU pj){
    return KernelDistance(pi._Position, pj._Position) < H;
}

bool AreNeighbours(float3 pi, float3 pj){
    return KernelDistance(pi, pj) < H;
}


float3 GetGradientSurface(ParticleGPU pi){
    // return StaggeredGridGetGradient(pi) + pi._HeightGradient;
    // TODO: restore it
    return float3(StaggeredGridGetGradient(pi).x, 0, 0);
}

[numthreads(128,1,1)]
void GenerateParticle(uint3 id : SV_DispatchThreadID){
    if(id.x == 0){
        uint i = _NbCurParticles;
        
        ParticleGPU p = _NewParticle[0];

        _Particles[i]        = p;
        _Positions[i]        = p._Position;
        _Heights[i]          = p._Height;
        _HeightsGradients[i] = p._HeightGradient;
        _Volumes[i]          = p._Volume;
    }
}

[numthreads(1024,1,1)]
void UpdateTerrainHeights(uint3 id : SV_DispatchThreadID){
    float3 pos = StaggeredGridGetPosition(id.x);
    float sumHeights = 0.0f;
    for(uint j=0; j<_NbCurParticles; j++){
        ParticleGPU pj = GetParticle(j);
        if(!AreNeighbours(pos, pj._Position)) continue;

        float wijHeight = W_POLY6(pos, pj._Position);

        sumHeights += wijHeight * pj._Volume;
    }

    _TerrainHeights[id.x] = SPIKE*sumHeights + pos.y;
    // _TerrainHeights[id.x] = pos.y + _NbCurParticles;
    // _TerrainHeights[id.x] = SPIKE*sumHeights + pos.y + 1;
}

[numthreads(128,1,1)]
void UpdateHeights(uint3 id : SV_DispatchThreadID){
    ParticleGPU pi = GetParticle(id);

    float sumHeights = 0.0f;
    float3 sumGrads  = float3(0.0f, 0.0f, 0.0f);

    for(uint j=0; j<_NbCurParticles; j++){
        ParticleGPU pj = GetParticle(j);
        if(!AreNeighbours(pi,pj)) continue;

        float  wijHeight = W_POLY6(pi, pj);
        float3 wijGrad   = W_POLY6_Grad(pi, pj);

        sumHeights += wijHeight * pj._Volume;
        sumGrads   += wijGrad * pj._Volume;
    }

    _Heights[id.x] = sumHeights;
    _HeightsGradients[id.x] = sumGrads;
}

[numthreads(128,1,1)]
void PropagateHeights(uint3 id : SV_DispatchThreadID){
    ParticleGPU pi = GetParticle(id);
    pi._Height = _Heights[id.x];
    pi._HeightGradient = _HeightsGradients[id.x];
    _Particles[id.x] = pi;
}

[numthreads(128,1,1)]
void TimeIntegration(uint3 id : SV_DispatchThreadID){
    ParticleGPU pi = GetParticle(id);

    float3 curPosition = pi._Position;
    // TODO: restore it
    float3 newVelocity = -10*GetGradientSurface(pi);
    // float3 newVelocity = (-G / STIFF)*GetGradientSurface(pi);
    float3 newPosition = DT*newVelocity + curPosition;

    newPosition.y = StaggeredGridGetHeight(newPosition);

    _Positions[id.x] = newPosition;
}

[numthreads(128,1,1)]
void PropagatePositions(uint3 id : SV_DispatchThreadID){
    ParticleGPU pi = GetParticle(id);
    pi._Position = _Positions[id.x];
    _Particles[id.x] = pi;
}