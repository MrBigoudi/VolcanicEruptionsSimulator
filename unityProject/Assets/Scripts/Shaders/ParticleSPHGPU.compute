// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GenerateParticle
#pragma kernel AssignCell
#pragma kernel FillNeighboursList
#pragma kernel UpdateHeights
#pragma kernel PropagateHeights
#pragma kernel TimeIntegration
#pragma kernel PropagatePositions

uniform float H;
uniform float PI;
uniform float G;

uniform float STIFF;
uniform float RHO_0;

uniform float ALPHA_POLY6;
uniform float ALPHA_POLY6_LAPLACIAN;
uniform float ALPHA_VISCOSITY;
uniform float ALPHA_VISCOSITY_LAPLACIAN;

uniform uint MAX_NEIGHBOURS;
uniform uint MAX_PARTICLES;

uniform uint GRID_NB_COLS;

uniform float DT;

struct StaggeredGridGPU{
    uint _NbCols, _NbLines;
    float _DeltaCols, _DeltaLines;
};

struct ParticleGPU{
    uint   _Id;
    float3 _Position;
    float  _Height;
    float3 _HeightGradient;
    float  _Volume;
    uint   _Cell;
};

uniform StructuredBuffer<StaggeredGridGPU> _StaggeredGrid;
uniform StructuredBuffer<float>  _StaggeredGridHeights;
uniform StructuredBuffer<float>  _StaggeredGridHalfHeightsCols;
uniform StructuredBuffer<float>  _StaggeredGridHalfHeightsLines;
uniform StructuredBuffer<float2> _StaggeredGridGradients;
uniform StructuredBuffer<float>  _StaggeredGridLaplacians;

RWStructuredBuffer<ParticleGPU> _Particles;
RWStructuredBuffer<float3> _Positions;
RWStructuredBuffer<float>  _Heights;
RWStructuredBuffer<float3> _HeightsGradients;
RWStructuredBuffer<float>  _Volumes;
RWStructuredBuffer<uint>   _Cells;

RWStructuredBuffer<uint>   _Neighbours;

uniform uint _NbCurParticles;
uniform StructuredBuffer<ParticleGPU> _NewParticle;

// ##################################################################################################################
// ################################### STAGGERED GRID ###############################################################
// ##################################################################################################################
uint StaggeredGridConvertIndices(uint posZ, uint posX){
    return posX + posZ * _StaggeredGrid[0]._NbCols;
}

uint2 StaggeredGridGetIndices(float3 pos){
    uint posX = (uint)(pos.x / _StaggeredGrid[0]._DeltaCols);
    uint posZ = (uint)(pos.z / _StaggeredGrid[0]._DeltaLines);
    return uint2(posZ, posX);
};

float StaggeredGridBilinearInterpolation(float x, float z, float xIdx, float zIdx, float upLeft, float upRight, float downLeft, float downRight){
    float xLeft  = xIdx*_StaggeredGrid[0]._DeltaCols;
    float xRight = (xIdx+1)*_StaggeredGrid[0]._DeltaCols;
    float zUp    = (zIdx+1)*_StaggeredGrid[0]._DeltaLines;
    float zDown  = zIdx*_StaggeredGrid[0]._DeltaLines;

    float res = (downLeft*(xRight-x)*(zUp-z))+(downRight*(x-xLeft)*(zUp-z)
                    +(upLeft*(xRight-x)*(z-zDown))+(upRight*(x-xLeft)*(z-zDown)));
    return res /= _StaggeredGrid[0]._DeltaCols*_StaggeredGrid[0]._DeltaLines;
}

float StaggeredGridGetHeight(float3 pos){
    uint2 indices = StaggeredGridGetIndices(pos);
    uint zIdx = indices[0];
    uint xIdx = indices[1];

    float x = pos.x;
    float z = pos.z;

    // interpolate height, bilinearly
    float upLeft    = _StaggeredGridHeights[StaggeredGridConvertIndices(zIdx+1, xIdx+0)];
    float upRight   = _StaggeredGridHeights[StaggeredGridConvertIndices(zIdx+1, xIdx+1)];
    float downLeft  = _StaggeredGridHeights[StaggeredGridConvertIndices(zIdx+0, xIdx+0)];
    float downRight = _StaggeredGridHeights[StaggeredGridConvertIndices(zIdx+0, xIdx+1)];

    float ownRes = StaggeredGridBilinearInterpolation(x, z, xIdx, zIdx, upLeft, upRight, downLeft, downRight);
    return ownRes;
}

float3 StaggeredGridGetGradient(ParticleGPU p){
    float3 pos = p._Position;
    uint2 indices = StaggeredGridGetIndices(pos);
    uint zIdx = indices[0];
    uint xIdx = indices[1];

    float x = pos.x;
    float z = pos.z;

    // interpolate gradients bilinearly
    float2 upLeft    = (zIdx >= _StaggeredGrid[0]._NbLines-1 || xIdx == 0)                           ? float2(0.0f, 0.0f) : _StaggeredGridGradients[StaggeredGridConvertIndices(zIdx-1+1, xIdx-1+0)];
    float2 upRight   = (zIdx >= _StaggeredGrid[0]._NbLines-1 || xIdx >= _StaggeredGrid[0]._NbCols-1) ? float2(0.0f, 0.0f) : _StaggeredGridGradients[StaggeredGridConvertIndices(zIdx-1+1, xIdx-1+1)];
    float2 downLeft  = (zIdx == 0 || xIdx == 0)                                                      ? float2(0.0f, 0.0f) : _StaggeredGridGradients[StaggeredGridConvertIndices(zIdx-1+0, xIdx-1+0)];
    float2 downRight = (zIdx == 0 || xIdx >= _StaggeredGrid[0]._NbCols-1)                            ? float2(0.0f, 0.0f) : _StaggeredGridGradients[StaggeredGridConvertIndices(zIdx-1+0, xIdx-1+1)];

    float dx = StaggeredGridBilinearInterpolation(x, z, xIdx, zIdx, upLeft.x, upRight.x, downLeft.x, downRight.x) - p._Height;
    float dz = StaggeredGridBilinearInterpolation(x, z, xIdx, zIdx, upLeft.y, upRight.y, downLeft.y, downRight.y) - p._Height;

    return float3(dx, pos.y, dz);
}

float StaggeredGridGetLaplacian(float3 pos){
    uint2 indices = StaggeredGridGetIndices(pos);
    uint zIdx = indices[0];
    uint xIdx = indices[1];

    float x = pos.x;
    float z = pos.z;

    // interpolate gradients bilinearly
    float upLeft    = (zIdx >= _StaggeredGrid[0]._NbLines-2 || xIdx <= 1)                           ? 0.0f : _StaggeredGridLaplacians[StaggeredGridConvertIndices(zIdx-2+1, xIdx-2+0)];
    float upRight   = (zIdx >= _StaggeredGrid[0]._NbLines-2 || xIdx >= _StaggeredGrid[0]._NbCols-2) ? 0.0f : _StaggeredGridLaplacians[StaggeredGridConvertIndices(zIdx-2+1, xIdx-2+1)];
    float downLeft  = (zIdx <= 1 || xIdx <= 1)                                                      ? 0.0f : _StaggeredGridLaplacians[StaggeredGridConvertIndices(zIdx-2+0, xIdx-2+0)];
    float downRight = (zIdx <= 1 || xIdx >= _StaggeredGrid[0]._NbCols-1)                            ? 0.0f : _StaggeredGridLaplacians[StaggeredGridConvertIndices(zIdx-2+0, xIdx-2+1)];

    float ownRes = StaggeredGridBilinearInterpolation(x, z, xIdx, zIdx, upLeft, upRight, downLeft, downRight);
    return ownRes;
}



// ##################################################################################################################
// ############################################### KERNEL ###########################################################
// ##################################################################################################################
float K_POLY6(float r){
    if(r<H) {
        float tmp = (H*H-r*r);
        return tmp*tmp*tmp;
    }
    else return 0.0f;
}


float K_POLY6_Prime(float r){
    if(r<H) {
        float tmp = ((H*H)-r*r);
        return -6.0f*r*tmp*tmp;
    }
    else return 0.0f;    
}

float K_POLY6_Lap(float r){
    if(r<H) {
        float tmp = ((H*H)-r*r);
        return tmp*(2*r*r-H*H);
    }
    else return 0.0f;
}

float K_VISCOSITY(float r){
    float l = H;
    if(r<l) {
        return r*r*(-4.0f*r + 9.0f*l) + l*l*l*(-5.0f + 6.0f*(log(l)-log(r)));
    }
    else return 0.0f;
}

float K_VISCOSITY_Prime(float r){
    float l = H;
    if(r<l) {
        if(r != 0) return r*(-12.0f*r + 18.0f*l) - (6.0f*l*l*l) / r;
        return 0.0f;
    }
    else return 0.0f;
}

float KernelDistance(float3 p1, float3 p2){
    return sqrt((p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y) + (p1.z-p2.z)*(p1.z-p2.z));
}

float W_POLY6(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position) / H;
    return ALPHA_POLY6 * K_POLY6(r);
}

float3 W_POLY6_Grad(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position) / H;
    return ALPHA_POLY6 * K_POLY6_Prime(r) * (p1._Position - p2._Position);
}

float W_POLY6_Derivated(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position) / H;
    return ALPHA_POLY6 * K_POLY6_Prime(r);
}

float W_POLY6_Lap(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position) / H;
    return ALPHA_POLY6_LAPLACIAN * K_POLY6_Lap(r);
}

float W_VISCOSITY(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position) / H;
    return ALPHA_VISCOSITY * K_VISCOSITY(r);
}

float3 W_VISCOSITY_Grad(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position) / H;
    float prime = K_VISCOSITY_Prime(r);
    float3 pos = (p1._Position - p2._Position);
    return ALPHA_VISCOSITY * prime * pos;
}

float W_VISCOSITY_Lap(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position) / H;
    float l = H;
    return ALPHA_VISCOSITY_LAPLACIAN*(l-r);
}

// ##################################################################################################################
// ############################################ SPH FUNCTIONS #######################################################
// ##################################################################################################################
ParticleGPU GetParticle(uint3 id : SV_DispatchThreadID){
    return _Particles[id.x];
}

ParticleGPU GetParticle(uint id){
    return _Particles[id];
}

bool AreNeighbours(ParticleGPU pi, ParticleGPU pj){
    float posX = pi._Position.x - pj._Position.x;
    float posZ = pi._Position.z - pj._Position.z;

    if(sqrt(posX*posX + posZ*posZ) < H){
        return true;
    }
    return false;
}

void SetNeighbour(uint nbNeighbours, ParticleGPU pi, uint pjIdx){
    _Neighbours[pi._Id * MAX_NEIGHBOURS + nbNeighbours] = pjIdx;
}

float3 GetGradientSurface(ParticleGPU pi){
    return StaggeredGridGetGradient(pi) + pi._HeightGradient;
}

[numthreads(100,1,1)]
void GenerateParticle(uint3 id : SV_DispatchThreadID){
    if(id.x == 0){
        uint i = _NbCurParticles - 1;
        
        ParticleGPU p = _NewParticle[0];

        _Particles[i]        = p;
        _Positions[i]        = p._Position;
        _Heights[i]          = p._Height;
        _HeightsGradients[i] = p._HeightGradient;
        _Volumes[i]          = p._Volume;
    }
}

[numthreads(100,1,1)]
void AssignCell(uint3 id : SV_DispatchThreadID){
    ParticleGPU p = GetParticle(id);
    uint i = (uint)(p._Position.x / (2*H));
    uint j = (uint)(p._Position.z / (2*H));
    uint index = i+j*GRID_NB_COLS;
    _Cells[id.x] = index;
    p._Cell = index;
}

[numthreads(100,1,1)]
void FillNeighboursList(uint3 id : SV_DispatchThreadID){
    ParticleGPU pi = GetParticle(id);
    uint nbNeighbours = 0;

    for(uint j=0; j<_NbCurParticles; j++){
        ParticleGPU pj = GetParticle(j);
        // check if same cells and if real neighbours
        if(pj._Cell == pi._Cell && AreNeighbours(pi, pj)){
            // update neighbour list
            SetNeighbour(nbNeighbours, pi, pj._Id);
            // update counter of neighbours and check if max reached
            if(nbNeighbours++ > MAX_NEIGHBOURS) break;
        }
    }

    // fill the rest of the places with -1
    for(uint i=nbNeighbours; i<MAX_NEIGHBOURS; i++){
        SetNeighbour(nbNeighbours, pi, -1);
    }
}

[numthreads(100,1,1)]
void UpdateHeights(uint3 id : SV_DispatchThreadID){
    ParticleGPU pi = GetParticle(id);
    uint firstNeighbour = pi._Id * MAX_NEIGHBOURS;
    uint lastNeighbour  = firstNeighbour + MAX_NEIGHBOURS;

    float sumHeights = 0.0f;
    float3 sumGrads  = float3(0.0f, 0.0f, 0.0f);

    for(uint j=0; j<_NbCurParticles; j++){
    // for(uint j=firstNeighbour; j<lastNeighbour; j++){
        // check if there are neighbour left
        // if(_Neighbours[j] == -1) return;

        ParticleGPU pj = _Particles[j];
        // ParticleGPU pj = GetParticle(_Neighbours[j]);
        if(KernelDistance(pi._Position, pj._Position) >= H) continue;

        float  wijHeight = W_POLY6(pi, pj);
        float3 wijGrad   = W_POLY6_Grad(pi, pj);

        sumHeights += wijHeight * pj._Volume;
        sumGrads   += wijGrad * pj._Volume;
    }

    _Heights[id.x] = sumHeights;
    _HeightsGradients[id.x] = sumGrads;
}

[numthreads(100,1,1)]
void PropagateHeights(uint3 id : SV_DispatchThreadID){
    ParticleGPU pi = GetParticle(id);
    pi._Height = _Heights[id.x];
    pi._HeightGradient = _HeightsGradients[id.x];
    _Particles[id.x] = pi;
}

[numthreads(100,1,1)]
void TimeIntegration(uint3 id : SV_DispatchThreadID){
    ParticleGPU pi = GetParticle(id);

    float3 curPosition = pi._Position;
    float3 newVelocity = (-G / STIFF)*GetGradientSurface(pi);
    float3 newPosition = DT*newVelocity + curPosition;

    newPosition.y = StaggeredGridGetHeight(newPosition);

    _Positions[id.x] = newPosition;
}

[numthreads(100,1,1)]
void PropagatePositions(uint3 id : SV_DispatchThreadID){
    ParticleGPU pi = GetParticle(id);
    pi._Position = _Positions[id.x];
    _Particles[id.x] = pi;
}