// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GenerateParticle
#pragma kernel UpdateDensities
#pragma kernel PropagateDensityUpdate
#pragma kernel UpdateHeights
#pragma kernel PropagateHeightUpdate
#pragma kernel TimeIntegration
#pragma kernel PropagatePositionUpdate
#pragma kernel UpdateTerrainDensities
#pragma kernel UpdateTerrainDensitiesStar
#pragma kernel UpdateTerrainHeights
#pragma kernel GaussianBlurTerrainHeights


uniform float H;
uniform float PI;
uniform float G;

uniform bool FirstTimeBlur;
uniform bool GaussianBlur;

uniform float STIFF;
uniform float RHO_0;

uniform float ALPHA_POLY6;
uniform float ALPHA_POLY6_LAPLACIAN;
uniform float ALPHA_VISCOSITY;
uniform float ALPHA_VISCOSITY_LAPLACIAN;

uniform float SPIKE;
uniform uint MAX_PARTICLES;
uniform uint _NbCurParticles;

uniform float DT;
uniform float RAND;

struct StaggeredGridGPU{
    uint _NbCols, _NbLines;
    float _DeltaCols, _DeltaLines;
};

struct ParticleGPU{
    float3 _Position;
    float  _Height;
    float3 _HeightGradient;
    float   _Density;
    float   _Mass;
    float  _Volume;
};

uniform StructuredBuffer<StaggeredGridGPU> _StaggeredGrid;
uniform StructuredBuffer<float>  _StaggeredGridHeights;
uniform StructuredBuffer<float>  _StaggeredGridHalfHeights;
uniform StructuredBuffer<float2> _StaggeredGridGradients;
uniform StructuredBuffer<float>  _StaggeredGridLaplacians;

RWStructuredBuffer<float> _TerrainHeightsTmp;
RWStructuredBuffer<float> _TerrainHeights;
RWStructuredBuffer<float> _InitialTerrainHeights;

RWStructuredBuffer<float> _TerrainDensities;
RWStructuredBuffer<float> _TerrainDensitiesHat;
RWStructuredBuffer<float> _TerrainDensitiesStar;
RWStructuredBuffer<float2> _TerrainDensitiesMinMax;
uniform float _TerrainDensityMax;
uniform float _TerrainDensityMin;

RWStructuredBuffer<ParticleGPU> _Particles;
RWStructuredBuffer<float3> _Positions;
RWStructuredBuffer<float>  _Heights;
RWStructuredBuffer<float3> _HeightsGradients;
RWStructuredBuffer<float>  _Volumes;
RWStructuredBuffer<float>  _Densities;
RWStructuredBuffer<float>  _Masses;

uniform uint _NbNewParticles;
uniform float3 _NewPosition;
uniform float _ParticleInitialHeight;

// ##################################################################################################################
// ################################### STAGGERED GRID ###############################################################
// ##################################################################################################################
uint StaggeredGridConvertIndices(uint posZ, uint posX){
    return posX + posZ * _StaggeredGrid[0]._NbCols;
}

uint StaggeredGridConvertIndicesHalf(uint posZ, uint posX){
    return posX + posZ * (_StaggeredGrid[0]._NbCols-1);
}

uint2 StaggeredGridGetIndices(float3 pos){
    uint posX = (uint)(pos.x / _StaggeredGrid[0]._DeltaCols);
    uint posZ = (uint)(pos.z / _StaggeredGrid[0]._DeltaLines);
    return uint2(posZ, posX);
};

float3 StaggeredGridGetPosition(uint id){
    uint yId = id / _StaggeredGrid[0]._NbCols;
    uint xId = id - yId * _StaggeredGrid[0]._NbCols;

    float x = xId*_StaggeredGrid[0]._DeltaCols;
    float y = _StaggeredGridHeights[id];
    float z = yId*_StaggeredGrid[0]._DeltaLines;
    
    return float3(x,y,z);
}

float StaggeredGridBilinearInterpolation(float x, float z, float xIdx, float zIdx, float w11, float w12, float w21, float w22){
    float xLeft  = xIdx*_StaggeredGrid[0]._DeltaCols;
    float xRight = (xIdx+1)*_StaggeredGrid[0]._DeltaCols;
    float zUp    = (zIdx+1)*_StaggeredGrid[0]._DeltaLines;
    float zDown  = zIdx*_StaggeredGrid[0]._DeltaLines;

    float x2_prime = xRight - x;
    float x1_prime = x - xLeft;
    float z2_prime = zUp - z;
    float z1_prime = z - zDown;

    float factor = 1.0/(_StaggeredGrid[0]._DeltaCols*_StaggeredGrid[0]._DeltaLines);


    float res = ((w11*x2_prime + w21*x1_prime)*z2_prime) + ((w12*x2_prime + w22*x1_prime)*z1_prime);

    return res *= factor;
}

float StaggeredGridGetHeight(float3 pos){
    uint2 indices = StaggeredGridGetIndices(pos);
    uint zIdx = indices[0];
    uint xIdx = indices[1];

    float x = pos.x;
    float z = pos.z;

    // interpolate height, bilinearly
    float upLeft    = (zIdx >= _StaggeredGrid[0]._NbLines-1 || xIdx <= 0)                           ? 0.0f : _StaggeredGridHalfHeights[StaggeredGridConvertIndicesHalf(zIdx, xIdx-1)];
    float upRight   = (zIdx >= _StaggeredGrid[0]._NbLines-1 || xIdx >= _StaggeredGrid[0]._NbCols-1) ? 0.0f : _StaggeredGridHalfHeights[StaggeredGridConvertIndicesHalf(zIdx, xIdx)];
    float downLeft  = (zIdx <= 0 || xIdx <= 0)                                                      ? 0.0f : _StaggeredGridHalfHeights[StaggeredGridConvertIndicesHalf(zIdx-1, xIdx-1)];
    float downRight = (zIdx <= 0 || xIdx >= _StaggeredGrid[0]._NbCols-1)                            ? 0.0f : _StaggeredGridHalfHeights[StaggeredGridConvertIndicesHalf(zIdx-1, xIdx)];

    float ownRes = StaggeredGridBilinearInterpolation(x, z, xIdx, zIdx, downLeft, upLeft, downRight, upRight);
    // float ownRes =  _StaggeredGridHeights[StaggeredGridConvertIndices(zIdx, xIdx)];
    // float ownRes =  _StaggeredGridHalfHeights[StaggeredGridConvertIndicesHalf(zIdx, xIdx)];
    return ownRes;
}

float3 StaggeredGridGetGradient(ParticleGPU p){
    float3 pos = p._Position;
    uint2 indices = StaggeredGridGetIndices(pos);
    uint zIdx = indices[0];
    uint xIdx = indices[1];

    float x = pos.x;
    float z = pos.z;

    // interpolate gradients bilinearly
    float2 upLeft    = (zIdx >= _StaggeredGrid[0]._NbLines-1 || xIdx <= 0)                           ? float2(0.0f, 0.0f) : _StaggeredGridGradients[StaggeredGridConvertIndicesHalf(zIdx, xIdx-1)];
    float2 upRight   = (zIdx >= _StaggeredGrid[0]._NbLines-1 || xIdx >= _StaggeredGrid[0]._NbCols-1) ? float2(0.0f, 0.0f) : _StaggeredGridGradients[StaggeredGridConvertIndicesHalf(zIdx, xIdx)];
    float2 downLeft  = (zIdx <= 0 || xIdx <= 0)                                                      ? float2(0.0f, 0.0f) : _StaggeredGridGradients[StaggeredGridConvertIndicesHalf(zIdx-1, xIdx-1)];
    float2 downRight = (zIdx <= 0 || xIdx >= _StaggeredGrid[0]._NbCols-1)                            ? float2(0.0f, 0.0f) : _StaggeredGridGradients[StaggeredGridConvertIndicesHalf(zIdx-1, xIdx)];

    float dx, dz;

    dx = StaggeredGridBilinearInterpolation(x, z, xIdx, zIdx, downLeft.x, upLeft.x, downRight.x, upRight.x);
    dz = StaggeredGridBilinearInterpolation(x, z, xIdx, zIdx, downLeft.y, upLeft.y, downRight.y, upRight.y);
    // if(xIdx >= _StaggeredGrid[0]._NbCols-1 || zIdx >= _StaggeredGrid[0]._NbLines-1){
    //     dx = 0.0f;
    //     dz = 0.0f;
    // } else {
    //     dx = _StaggeredGridGradients[StaggeredGridConvertIndicesHalf(zIdx, xIdx)].x;
    //     dz = _StaggeredGridGradients[StaggeredGridConvertIndicesHalf(zIdx, xIdx)].y;
    // }

    return float3(dx, pos.y, dz);
}

float StaggeredGridGetLaplacian(float3 pos){
    uint2 indices = StaggeredGridGetIndices(pos);
    uint zIdx = indices[0];
    uint xIdx = indices[1];

    float x = pos.x;
    float z = pos.z;

    // interpolate gradients bilinearly
    float upLeft    = (zIdx >= _StaggeredGrid[0]._NbLines-2 || xIdx <= 1)                           ? 0.0f : _StaggeredGridLaplacians[StaggeredGridConvertIndices(zIdx-2+1, xIdx-2+0)];
    float upRight   = (zIdx >= _StaggeredGrid[0]._NbLines-2 || xIdx >= _StaggeredGrid[0]._NbCols-2) ? 0.0f : _StaggeredGridLaplacians[StaggeredGridConvertIndices(zIdx-2+1, xIdx-2+1)];
    float downLeft  = (zIdx <= 1 || xIdx <= 1)                                                      ? 0.0f : _StaggeredGridLaplacians[StaggeredGridConvertIndices(zIdx-2+0, xIdx-2+0)];
    float downRight = (zIdx <= 1 || xIdx >= _StaggeredGrid[0]._NbCols-1)                            ? 0.0f : _StaggeredGridLaplacians[StaggeredGridConvertIndices(zIdx-2+0, xIdx-2+1)];

    float ownRes = StaggeredGridBilinearInterpolation(x, z, xIdx, zIdx, upLeft, upRight, downLeft, downRight);
    return ownRes;
}



// ##################################################################################################################
// ############################################### KERNEL ###########################################################
// ##################################################################################################################
float K_POLY6(float r){
    if(r<H) {
        float tmp = (H*H-r*r);
        return tmp*tmp*tmp;
    }
    else return 0.0f;
}


float K_POLY6_Prime(float r){
    if(r<H) {
        float tmp = ((H*H)-r*r);
        return -6.0f*r*tmp*tmp;
    }
    else return 0.0f;    
}

float K_POLY6_Lap(float r){
    if(r<H) {
        float tmp = ((H*H)-r*r);
        return tmp*(2*r*r-H*H);
    }
    else return 0.0f;
}

float K_VISCOSITY(float r){
    float l = H;
    if(r<l) {
        return r*r*(-4.0f*r + 9.0f*l) + l*l*l*(-5.0f + 6.0f*(log(l)-log(r)));
    }
    else return 0.0f;
}

float K_VISCOSITY_Prime(float r){
    float l = H;
    if(r<l) {
        if(r != 0) return r*(-12.0f*r + 18.0f*l) - (6.0f*l*l*l) / r;
        return 0.0f;
    }
    else return 0.0f;
}

float KernelDistance(float3 p1, float3 p2){
    return sqrt((p1.x-p2.x)*(p1.x-p2.x) + (p1.z-p2.z)*(p1.z-p2.z));
}

float W_POLY6(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position);
    return ALPHA_POLY6 * K_POLY6(r);
}

float W_POLY6(float3 p1, float3 p2){
    float r = KernelDistance(p1, p2);
    return ALPHA_POLY6 * K_POLY6(r);
}

float3 W_POLY6_Grad(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position);
    if(r==0) return float3(0,0,0);
    return ALPHA_POLY6 * K_POLY6_Prime(r) * (p1._Position - p2._Position) / r;
}

float W_POLY6_Derivated(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position);
    return ALPHA_POLY6 * K_POLY6_Prime(r);
}

float W_POLY6_Lap(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position);
    return ALPHA_POLY6_LAPLACIAN * K_POLY6_Lap(r);
}

float W_VISCOSITY(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position);
    return ALPHA_VISCOSITY * K_VISCOSITY(r);
}

float3 W_VISCOSITY_Grad(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position);
    float prime = K_VISCOSITY_Prime(r);
    float3 pos = (p1._Position - p2._Position);
    return ALPHA_VISCOSITY * prime * pos;
}

float W_VISCOSITY_Lap(ParticleGPU p1, ParticleGPU p2){
    float r = KernelDistance(p1._Position, p2._Position);
    float l = H;
    return ALPHA_VISCOSITY_LAPLACIAN*(l-r);
}

// ##################################################################################################################
// ############################################ SPH FUNCTIONS #######################################################
// ##################################################################################################################
ParticleGPU GetParticle(uint3 id : SV_DispatchThreadID){
    return _Particles[id.x];
}

ParticleGPU GetParticle(uint id){
    return _Particles[id];
}

bool AreNeighbours(ParticleGPU pi, ParticleGPU pj){
    return KernelDistance(pi._Position, pj._Position) < H;
}

bool AreNeighbours(float3 pi, float3 pj){
    return KernelDistance(pi, pj) < H;
}


float3 GetGradientSurface(ParticleGPU pi){
    return StaggeredGridGetGradient(pi) + pi._HeightGradient;
    // return float3(StaggeredGridGetGradient(pi).x, 0, 0);
}

bool IsUpTerrainBorder(uint3 id : SV_DispatchThreadID){
    return id.x >= _StaggeredGrid[0]._NbCols * (_StaggeredGrid[0]._NbLines - 1);
}
bool IsDownTerrainBorder(uint3 id : SV_DispatchThreadID){
    return id.x < _StaggeredGrid[0]._NbCols;
}
bool IsLeftTerrainBorder(uint3 id : SV_DispatchThreadID){
    return id.x % _StaggeredGrid[0]._NbCols == 0;
}
bool IsRightTerrainBorder(uint3 id : SV_DispatchThreadID){
    return id.x % _StaggeredGrid[0]._NbCols == _StaggeredGrid[0]._NbCols - 1;
}

uint GetUpLeftTerrain(uint3 id : SV_DispatchThreadID){
    return id.x + _StaggeredGrid[0]._NbCols - 1;
}
uint GetUpMiddleTerrain(uint3 id : SV_DispatchThreadID){
    return id.x + _StaggeredGrid[0]._NbCols;
}
uint GetUpRightTerrain(uint3 id : SV_DispatchThreadID){
    return id.x + _StaggeredGrid[0]._NbCols + 1;
}

uint GetMiddleLeftTerrain(uint3 id : SV_DispatchThreadID){
    return id.x - 1;
}
uint GetMiddleMiddleTerrain(uint3 id : SV_DispatchThreadID){
    return id.x;
}
uint GetMiddleRightTerrain(uint3 id : SV_DispatchThreadID){
    return id.x + 1;
}

uint GetDownLeftTerrain(uint3 id : SV_DispatchThreadID){
    return id.x - _StaggeredGrid[0]._NbCols - 1;
}
uint GetDownMiddleTerrain(uint3 id : SV_DispatchThreadID){
    return id.x - _StaggeredGrid[0]._NbCols;
}
uint GetDownRightTerrain(uint3 id : SV_DispatchThreadID){
    return id.x - _StaggeredGrid[0]._NbCols + 1;
}

[numthreads(1024,1,1)]
void GaussianBlurTerrainHeights(uint3 id : SV_DispatchThreadID){
    float w11 = IsUpTerrainBorder(id) || IsLeftTerrainBorder(id) ? 0.0f : _TerrainHeightsTmp[GetUpLeftTerrain(id)];
    float w12 = IsUpTerrainBorder(id) ? 0.0f : _TerrainHeightsTmp[GetUpMiddleTerrain(id)];
    float w13 = IsUpTerrainBorder(id) || IsRightTerrainBorder(id) ? 0.0f : _TerrainHeightsTmp[GetUpRightTerrain(id)];
    float w21 = IsLeftTerrainBorder(id) ? 0.0f : _TerrainHeightsTmp[GetMiddleLeftTerrain(id)];
    float w22 = _TerrainHeightsTmp[GetMiddleMiddleTerrain(id)];
    float w23 = IsRightTerrainBorder(id) ? 0.0f : _TerrainHeightsTmp[GetMiddleRightTerrain(id)];
    float w31 = IsDownTerrainBorder(id) || IsLeftTerrainBorder(id)  ? 0.0f : _TerrainHeightsTmp[GetDownLeftTerrain(id)];
    float w32 = IsDownTerrainBorder(id) || IsLeftTerrainBorder(id)  ? 0.0f : _TerrainHeightsTmp[GetDownMiddleTerrain(id)];
    float w33 = IsDownTerrainBorder(id) || IsLeftTerrainBorder(id)  ? 0.0f : _TerrainHeightsTmp[GetDownRightTerrain(id)];

    float GaussFactor = 1.0f/16.0f;
    float GaussMatrix[9] = {1, 2, 1, 2, 4, 2, 1, 2, 1};

    float res =   w11*GaussMatrix[0]*GaussFactor + w12*GaussMatrix[1]*GaussFactor + w13*GaussMatrix[2]*GaussFactor
                + w21*GaussMatrix[3]*GaussFactor + w22*GaussMatrix[4]*GaussFactor + w23*GaussMatrix[5]*GaussFactor
                + w31*GaussMatrix[6]*GaussFactor + w32*GaussMatrix[7]*GaussFactor + w33*GaussMatrix[8]*GaussFactor;

    if(GaussFactor == 0.0f)
        res = w22;

    if(FirstTimeBlur) _InitialTerrainHeights[id.x] = res;
    _TerrainHeights[id.x] = res;
}

[numthreads(128,1,1)]
void PropagateDensityUpdate(uint3 id : SV_DispatchThreadID){
    if(id.x >= _NbCurParticles) return;
    ParticleGPU pi = GetParticle(id);
    pi._Density = _Densities[id.x];
    pi._Volume  = _Volumes[id.x];
    _Particles[id.x] = pi;
}

[numthreads(128,1,1)]
void PropagateHeightUpdate(uint3 id : SV_DispatchThreadID){
    if(id.x >= _NbCurParticles) return;
    ParticleGPU pi = GetParticle(id);
    pi._Height         = _Heights[id.x];
    pi._HeightGradient = _HeightsGradients[id.x];
    _Particles[id.x] = pi;
}

[numthreads(128,1,1)]
void PropagatePositionUpdate(uint3 id : SV_DispatchThreadID){
    if(id.x >= _NbCurParticles) return;
    ParticleGPU pi = GetParticle(id);
    pi._Position = _Positions[id.x];
    _Particles[id.x] = pi;
}

float3 GenRandomPos(float3 pos, uint id){
    return float3(sin(RAND + id)+pos.x, pos.y, -cos(RAND+id)+pos.z);
}

[numthreads(128,1,1)]
void GenerateParticle(uint3 id : SV_DispatchThreadID){
    if(id.x < _NbNewParticles){
        uint i = (_NbCurParticles - 1 - id.x);

        float density = RHO_0;
        // float mass = H*H*H*RHO_0; // Ihmsen et al 2013
        float a = (2.0/3.0)*H;
        float mass = a*a*a*RHO_0;
        float volume = mass / density;

        float radius = pow(abs((3*volume / (4*PI))), (1.0f/3.0f));

        ParticleGPU p; 
        p._Position = GenRandomPos(_NewPosition, id.x);
        // p._Height = radius / 2.0f;
        p._Height = _ParticleInitialHeight,
        p._HeightGradient = float3(0,0,0);
        p._Density = density;
        p._Mass = mass;
        p._Volume = volume;
        
        _Positions[i]        = p._Position;
        _Heights[i]          = p._Height;
        _HeightsGradients[i] = p._HeightGradient;
        _Volumes[i]          = p._Volume;
        _Particles[i]        = p;

    }
}

void UpdateTerrainDensitiesMinMax(uint id, uint maxIdx){
    float3 pos = StaggeredGridGetPosition(id);

    // get number of cells arround me that are inside kernel
    int nbCells = H / _StaggeredGrid[0]._DeltaCols;

    float densityMin = -1.0f;
    float densityMax = -1.0f;

    // check cells inside radius
    for(int j=-nbCells; j<nbCells; j++){
        for(int i=-nbCells; i<nbCells; i++){
            int curCell = id + i + (j*_StaggeredGrid[0]._NbCols);
            
            // do not count cells outside the grid
            if(curCell < 0 || curCell >= (int)maxIdx) continue;

            // update min and max densities
            float curDensity = _TerrainDensities[(uint)curCell];
            if(densityMin < 0 || curDensity < densityMin){
                densityMin = curDensity;
            }
            if(densityMax < 0 || curDensity > densityMax){
                densityMax = curDensity;
            }
        }
    }

    _TerrainDensitiesMinMax[id] = float2(densityMin, densityMax);
}

void UpdateDensitiesStar(uint id){
    float density    = _TerrainDensities[id];
    float densityHat = _TerrainDensitiesHat[id];
    float densityMin = _TerrainDensitiesMinMax[id].x;
    float densityMax = _TerrainDensitiesMinMax[id].y;
    
    if(densityMax == densityMin){
        _TerrainDensitiesStar[id] = 0.0f;
        return;
    }

    float alpha = (density-densityMin) / (densityMax-densityMin);
    // if((density-densityMin)<0) alpha = 0;
    float densityStar = alpha*densityHat + (1-alpha)*density;

    _TerrainDensitiesStar[id] = densityStar;
}

[numthreads(1024,1,1)]
void UpdateTerrainDensitiesStar(uint3 id : SV_DispatchThreadID){
    uint maxIdx = _StaggeredGrid[0]._NbCols * _StaggeredGrid[0]._NbLines;
    if(id.x >= maxIdx) return;
    UpdateTerrainDensitiesMinMax(id.x, maxIdx);
    UpdateDensitiesStar(id.x);
}

float W_POLY6_Densities(float3 p1, float3 p2, float h){
    float r = KernelDistance(p1, p2);
    if(r<0 || r>h) return 0.0f;
    float alpha = 4/(PI*h*h*h*h*h*h*h*h);
    float tmp = (h*h - r*r);
    return alpha*tmp*tmp*tmp;
}

float GetKernelRadius(float density){
    if(density < _TerrainDensityMin || density > _TerrainDensityMax) return H;
    float a = 2*H / (_TerrainDensityMax - _TerrainDensityMin);
    float b = H - ((_TerrainDensityMax - _TerrainDensityMin) / (2*H*_TerrainDensityMin));
    return a*density + b;
}

[numthreads(1024,1,1)]
void UpdateTerrainDensities(uint3 id : SV_DispatchThreadID){
    if(id.x >= _StaggeredGrid[0]._NbCols * _StaggeredGrid[0]._NbLines) return;
    float3 pos = StaggeredGridGetPosition(id.x);

    float sumDensities = 0.0f;
    float sumWeights = 0.0f;

    // float kernelRadius = GetKernelRadius(_TerrainDensities[id.x]);
    float kernelRadius = H;

    for(uint j=0; j<_NbCurParticles; j++){
        ParticleGPU pj = GetParticle(j);
        if(!AreNeighbours(pos, pj._Position)) continue;

        float wij = W_POLY6_Densities(pos, pj._Position, kernelRadius);

        sumDensities += pj._Density*wij;
        sumWeights  += wij;
    }

    _TerrainDensities[id.x] = sumDensities;
    _TerrainDensitiesHat[id.x] = sumWeights < 0.0001f ? 0.0f : sumDensities / sumWeights;
}

[numthreads(1024,1,1)]
void UpdateTerrainHeights(uint3 id : SV_DispatchThreadID){
    if(id.x >= _StaggeredGrid[0]._NbCols * _StaggeredGrid[0]._NbLines) return;
    
    float newHeight = SPIKE*(_TerrainDensitiesStar[id.x] / RHO_0) + _InitialTerrainHeights[id.x];
    
    _TerrainHeightsTmp[id.x] = newHeight;
    if(!GaussianBlur) _TerrainHeights[id.x] = newHeight;
}


[numthreads(128,1,1)]
void UpdateDensities(uint3 id : SV_DispatchThreadID){
    if(id.x >= _NbCurParticles) return;
    ParticleGPU pi = GetParticle(id);

    float sumMasses = 0.0f;
    // int cpt = 0;

    for(uint j=0; j<_NbCurParticles; j++){
        ParticleGPU pj = GetParticle(j);
        if(!AreNeighbours(pi,pj)) continue;

        float wijMass = W_POLY6(pi, pj);
        sumMasses += wijMass * pj._Mass;
        // TODO:
        // _Positions[id.x] = wijMass > 0.99 && wijMass < 1.01 ? _Positions[id.x] : float3(0,0,0);
        // cpt++;
    }

    _Densities[id.x] = sumMasses;
    // _Volumes[id.x] = pi._Mass / sumMasses;
}

[numthreads(128,1,1)]
void UpdateHeights(uint3 id : SV_DispatchThreadID){
    if(id.x >= _NbCurParticles) return;
    ParticleGPU pi = GetParticle(id);

    float sumHeights = 0.0f;
    // float sumWeights = 0.0f;
    
    float3 sumGrads  = float3(0.0f, 0.0f, 0.0f);

    for(uint j=0; j<_NbCurParticles; j++){
        ParticleGPU pj = GetParticle(j);
        if(!AreNeighbours(pi,pj)) continue;

        float  wijHeight = W_POLY6(pi, pj);
        float3 wijGrad   = W_POLY6_Grad(pi, pj);

        sumHeights += wijHeight * pj._Volume;
        sumGrads   += wijGrad * pj._Volume;
        // sumWeights += wijHeight;
    }

    // if(sumHeights == 0) sumHeights = 100;
    // TODO:
    // _Heights[id.x] = sumWeights >= 0.0001f ? sumHeights / sumWeights : -10.0f; // shouldn't be possible
    // _Heights[id.x] = pi._Height;
    _Heights[id.x] = sumHeights;
    _HeightsGradients[id.x] = sumGrads;
}

[numthreads(128,1,1)]
void TimeIntegration(uint3 id : SV_DispatchThreadID){
    if(id.x >= _NbCurParticles) return;
    ParticleGPU pi = GetParticle(id);

    float3 curPosition = pi._Position;
    float3 newVelocity = (-G/STIFF)*GetGradientSurface(pi);
    // if(newVelocity.x <= 0.0001f && newVelocity.z <= 0.0001f) newVelocity = float3(-1,0,0);
    float3 newPosition = DT*newVelocity + curPosition;

    newPosition.y = StaggeredGridGetHeight(newPosition);

    // TODO:
    // if(curPosition.x <= 1e-6 && curPosition.z <= 1e-6) newPosition = float3(256, StaggeredGridGetHeight(float3(256, 0, 256)), 256);
    _Positions[id.x] = newPosition;
    // _Positions[id.x] = curPosition;
}